;
;	MONITOR FUNCTIONS
;

GETL		EQU	$0003	; Inputs one line of text from the keyboard.
CRLF2		EQU	$0006	; Places cursor at start of new line
CRLF		EQU	$0009	; Places cursor at start of new line if it wasn't already at the start
PRNTSPACE	EQU	$000C	; Print a space character
PRNT		EQU	$0012	; Print a character (or control)
MESSAGE		EQU	$0015	; Print a string
GETKY		EQU	$001B	; Get the current key pressed
PRTWRD		EQU	$03BA	; Output a 16-bit hexadecimal number contained in HL to the screen
PRTBYT		EQU	$03C3	; Output a hexadecimal number contained in A to the screen
DIGASC		EQU	$03DA	
DISPAC		EQU	$0BCE	; Convert a display code stored in A into its ASCII code
ASCWRD		EQU	$0410	; Convert AF,HL ASCII into hex and store in HL
CALVAD		EQU	$0FB4	; Compute the vram address of pixel position stored in HL (H=row, L=col)

;
;	EQUATES
;

FLOORHEIGHT	EQU	21
GRAVITY		EQU	1
MAXSPEED	EQU	1<<3


; CHARACTERS
SPACESHIP	EQU	$C7
PLAYERSYM	EQU	$DF

; KEYS
LEFTKEY		EQU	$41
RIGHTKEY	EQU	$44
SPACEKEY	EQU	$20

; ADDRESSES
VIDMEM      EQU $D000

;
;	MACROS
;

PRINT		MACRO
	LD		DE,	%1
	CALL	MESSAGE
ENDM

PRINTLN		MACRO
	IF '%1'
		PRINT %1
		CALL CRLF
	ELSE
		CALL CRLF2
	ENDIF
ENDM

CURHOME		MACRO
	LD		A,	$15
	CALL	PRNT
ENDM

CLS			MACRO
	LD		A,	$16
	CALL	PRNT
ENDM

SLEEPX		MACRO				; Sleep for 0x?? * 0x?? iterations
	PUSH	DE
	PUSH	BC
	IF %1<1
		LD DE, 1
	ELSE
		LD DE, %1
	ENDIF
	
	IF '%2'
		IF %2<1
			LD B, 1
		ELSE
			LD B, %2
		ENDIF
	ELSE
		LD B, 1
	ENDIF
	LD		(SLEEPCOUNT),	DE
	CALL	SLEEP
	POP		BC
	POP		DE
ENDM

DRAWBOOL	MACRO
	LD		A,	(%1)
	ADD		A,	32
	LD		(VIDMEM+%2+%3*40), A
ENDM

SETBYTE		MACRO
	LD		A,	%2
	LD		(%1),	A
ENDM

SETBYTEND	MACRO				; Non destructive version of SETBYTE
	PUSH	AF
	SETBYTE	%1,	%2
	POP		AF
ENDM

PIXTOMEM	MACRO				; Load X/Y position from pointer arg1 and calculate memory address into HL
	LD		HL, (%1)			; Load obj pixel position into HL
	CALL	CALVAD
ENDM

POSTOPIX	MACRO				; Convert X/Y fixed-point position into pixel position and store in HL
	LD		A,	(%1)			; Convert & save X
	SRL		A
	SRL		A
	LD		L,	A

	LD		A,	(%2)			; Convert & save Y
	SRL		A
	SRL		A
	LD		H,	A
ENDM

POSTOMEM	MACRO
	POSTOPIX	%1,	%2
	CALL	CALVAD
ENDM

PRINTRA		MACRO				; Print the contents of A onto the screen as Hex value (non destructive to AF)
	PUSH	AF
	CALL	PRTBYT
	POP		AF
ENDM

;
;	C = PLAYERY < FLOORHEIGHT - 0.25
;
TESTONFLOOR	MACRO				; C is set if not on floor
	LD		A,	(PLAYERY)
	CP		(FLOORHEIGHT<<2) - 1
ENDM

CP16		MACRO				; Compare two 16-bit numbers without changing their values
	PUSH	HL
	PUSH	BC
	OR		A					; Clear carry flag
	SBC		HL,	BC
	POP		BC
	POP		HL
ENDM





;
;	CODE
;





	ORG		$1200

	CLS							; force clear screen
DRAWFLOOR:
	LD		BC,	40
	LD		HL,	FLOORHEIGHT+1:00
	CALL	CALVAD
	EX		DE,	HL
	LD		HL,	FLOOR
	LDIR
START:
	POSTOMEM	PLAYERX,	PLAYERY

    LD      (HL),   PLAYERSYM	; Draw player

	; DEBUG
	PUSH	HL
	CURHOME
	LD		HL,	(PLAYERX)
	CALL	PRTWRD
	CALL	PRNTSPACE
	LD		HL,	(PLAYVELX)
	CALL	PRTWRD
	DRAWBOOL	FLAGFLOOR,	0,	1
	DRAWBOOL	KEYDOWN,	0,	2
	DRAWBOOL	FLAGACCX,	0,	3
	POP		HL

	;REPT	4
		SLEEPX	$AA, $10
		CALL	CONTROLS
		CALL	CHECKKEYDOWN
	;ENDM
	; TODO: Fix flickering
	LD		(HL),	$00			; Clear location
CM:
	CALL	MOVE
	JP		START


WAIT1:							; Wait while key is down
	CALL	GETKY
	JP		NZ,	WAIT1
WAIT2:							; Wait until key is pressed
	CALL	GETKY
	JP		Z,	WAIT2
EXIT:
	CLS							; force clear screen
	PRINTLN	MSGEXIT
	JP		$00AD				; Exit to Monitor


;
;	FUNCTIONS
;


;
;	if(key == 0) { // no input
;		keydown = 0;
;	} else { // detected input
;		keydown = 1;
;	}
;
CHECKKEYDOWN:
	CALL	GETKY				; 00 if not pressed
	JP		NZ,	KEYDETECT		; jump if detected keypress
	SETBYTE	KEYDOWN,	0		; Reset keydown if no key detected
	RET
KEYDETECT:
	SETBYTE	KEYDOWN,	1		; Set if key detected
	RET

;
;	if(keydown == RIGHTKEY) {
;		BOOLRIGHT = 1;
;		return;
;	}
;	if(keydown == LEFTKEY) {
;		BOOLRIGHT = 0;
;		return;
;	}
;
CONTROLS:
	CALL	GETKY
	RET		Z					; Do nothing if no key pressed
	CP		RIGHTKEY
	JP		Z,	MOVERIGHT		; if right pressed
	CP		LEFTKEY
	JP		Z,	MOVELEFT		; if left pressed
	CP		SPACEKEY			
	JP		Z,	JUMP			; if space pressed
	RET							; Return if neither left nor right were pressed
MOVERIGHT:
	SETBYTE	BOOLRIGHT,	1
	LD		A,	(PLAYVELX)
	INC		A
	CALL	CLAMPVELX
	LD		(PLAYVELX),	A
	RET
MOVELEFT:
	SETBYTE	BOOLRIGHT,	0
	LD		A,	(PLAYVELX)
	DEC		A
	CALL	CLAMPVELX
	LD		(PLAYVELX),	A
	RET
JUMP:
	TESTONFLOOR					; Check if on floor
	RET		C					; Return if player is not on the floor
	SETBYTE	PLAYVELY,	(-1<<3) -4
	LD		A,	(PLAYERY)
	SUB		1<<1
	LD		(PLAYERY), A
	RET

CLAMPVELX:						; This assumes xVel is loaded into reg A
	CP		0
	JP		M,	CVXNEG
CVXPOS:
	PRINT	MSGR
	;LD		A,	(PLAYVELX)
	CP		MAXSPEED
	JP		P,	CVXPOSMAX
	RET
CVXNEG:
	PRINT	MSGL
	CP		MAXSPEED
	JP		M,	CVXNEGMAX
	RET
CVXPOSMAX:
	LD		A,	MAXSPEED
	RET
CVXNEGMAX:
	LD		A, -MAXSPEED
	RET

TOGGLEDIR:
	LD		A,	(BOOLRIGHT)
	XOR		1
	LD		(BOOLRIGHT),	A
	RET

MOVE:							; Update playerx and playery values
	; Gravity
	TESTONFLOOR					; Check if on floor
	SETBYTEND	FLAGFLOOR,	0
	LD		A,	0				; If on floor, set Y velocity to 0 (p1)
	JP		NC,	MOVE1			; If on floor, skip gravity
	SETBYTEND	FLAGFLOOR,	1
	LD		A,	(PLAYERY)		; Increment PLAYERY if not on floor
	LD		HL,	PLAYVELY
	ADD		A,	(HL)
	LD		(PLAYERY),	A

	TESTONFLOOR					; Check if on or below floor and fix ypos and yvel
	JP		C,	MOVE2			; If not on floor, add gravity
	LD		A,	FLOORHEIGHT<<2	; If on or below floor, set y to floor
	LD		(PLAYERY),	A
	LD		A,	0				; If on floor, set Y velocity to 0 (p1)
	JP		MOVE1
MOVE2:
	; Update Y velocity
	LD		A,	(PLAYVELY)
	ADD		A,	GRAVITY
MOVE1:
	LD		(PLAYVELY),	A		; set Y velocity to either 0 or Yvel-Gravity (p2)
	LD		A,	(KEYDOWN)		; Test if a key is currently being held
	OR		A
	LD		A,	(PLAYVELX)
	JP		NZ,	MOVEX			; If a key is pressed, move

	SETBYTEND	FLAGACCX,	0

	PUSH	AF
	TESTONFLOOR
	POP		AF
	JP		C,	MOVEX
	
	CALL	STEPTOZERO			; Gradually reduce Xvel to 0 if no key pressed
	LD		(PLAYVELX),	A
MOVEX:
	LD		HL,	PLAYERX			; Add Xvel to Xpos
	ADD		A,	(HL)
	LD		(PLAYERX),	A
MOVEXWALL:						; Wrap player around screen
	SRL		A					; 
	CP		-10
	JP		M,	MOVEXWALLLEFT	; Player has gone left off screen
	CP		(39<<1)+1
	RET		M					; Player has not gone right off screen
MOVEXWALLRIGHT:
	PRINT	MSGR
	SETBYTE	PLAYERX,	0
	RET
MOVEXWALLLEFT:
	PRINT	MSGL
	SETBYTE	PLAYERX,	39<<2
	RET

IMULT:							; Multiply D by E and store the result in HL.
	LD		HL,	0
	LD		A,	D
	OR		A
	RET		Z
	LD		B,	D
	LD		D,	H
IML:
	ADD		HL,	DE
	DJNZ	IML
	RET

SLEEP:							; Sleep for a given number of iterations
	LD		A,	(SLEEPCOUNT)
SLEEP1:
	SUB		1
	OR		A
	JP		NZ,	SLEEP1
	DJNZ	SLEEP
	RET

STEPTOZERO:						; INC/DEC A towards zero depending on polarity
	CP		0
	RET		Z					; Already zero
	JP		M,	STZNEG			; Negative
STZPOS:
	SETBYTEND	FLAGACCX,	1
	DEC		A
	RET
STZNEG:
	SETBYTEND	FLAGACCX,	2
	INC		A
	RET

; TODO: Verify characters are being assembled correctly
; CHRMAP		"MZ-ASCII-EU"

MSG1:		DB	"ENTER 2* 2-DIGIT HEX #S W/O SPACE", $0D
FLOOR:		DB	"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"
MSGR:		DB	" RIGHT ", $0D
MSGL:		DB	" LEFT ", $0D
MSGRES:		DB	"RESULT:", $0D
MSGEXIT:	DB	"EXITED PROGRAM", $0D
SLEEPCOUNT:	DS	2	; Reserve 2 bytes of memory (zeroed)
BOOLRIGHT:	DB	$01
KEYDOWN:	DB	$00	; If a key is being held down
PLAYERX:	DB	$00
PLAYERY:	DB	FLOORHEIGHT<<2
PLAYVELX:	DB	$00
PLAYVELY:	DB	$00
FLAGFLOOR:	DB	$00	; An indicator flag for debugging
FLAGACCX:	DB	$00

END

