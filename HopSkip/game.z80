;
;	MONITOR FUNCTIONS
;

GETL		EQU	$0003	; Inputs one line of text from the keyboard.
CRLF2		EQU	$0006	; Places cursor at start of new line
CRLF		EQU	$0009	; Places cursor at start of new line if it wasn't already at the start
PRNTSPACE	EQU	$000C	; Print a space character
PRNT		EQU	$0012	; Print a character (or control)
MESSAGE		EQU	$0015	; Print a string
GETKY		EQU	$001B	; Get the current key pressed
PRTWRD		EQU	$03BA	; Output a 16-bit hexadecimal number contained in HL to the screen
PRTBYT		EQU	$03C3	; Output a hexadecimal number contained in A to the screen
DIGASC		EQU	$03DA	
BRKTST		EQU	$0A44	; Test if break key is pressed
SNCV		EQU	$0DA6	; Wait for V-Blank
DISPAC		EQU	$0BCE	; Convert a display code stored in A into its ASCII code
ASCWRD		EQU	$0410	; Convert AF,HL ASCII into hex and store in HL
MOVECU		EQU	$0DDC	; Control the V.D.U.
CALVAD		EQU	$0FB4	; Compute the vram address of pixel position stored in HL (H=row, L=col)

;
;	EQUATES
;

FLOORHEIGHT	EQU	21
GRAVITY		EQU	0000_0001B
MAXSPEED	EQU	0000_0110B
OBJCOUNT	EQU	4
OBJVALS		EQU	8
JUMPSPEED	EQU	-0000_1011B		; (-1<<3) -3


; CHARACTERS
SPACESHIP	EQU	$C7
PLAYERSYM	EQU	$DF

; KEYS
LEFTKEY		EQU	$41
RIGHTKEY	EQU	$44
SPACEKEY	EQU	$20

; ADDRESSES
VIDMEM      EQU $D000

;
;	MACROS
;

PRINT		MACRO
	LD		DE,	%1
	CALL	MESSAGE
ENDM

PRINTLN		MACRO
	IF '%1'
		PRINT %1
		CALL CRLF
	ELSE
		CALL CRLF2
	ENDIF
ENDM

CURHOME		MACRO
	PUSH	AF
	LD		A,	$15
	CALL	PRNT
	POP		AF
ENDM

CLS			MACRO
	LD		A,	$16
	CALL	PRNT
ENDM

SLEEPX		MACRO				; Sleep for 0x?? * 0x?? iterations
	PUSH	DE
	PUSH	BC
	IF %1<1
		LD DE, 1
	ELSE
		LD DE, %1
	ENDIF
	
	IF '%2'
		IF %2<1
			LD B, 1
		ELSE
			LD B, %2
		ENDIF
	ELSE
		LD B, 1
	ENDIF
	LD		(SLEEPCOUNT),	DE
	CALL	SLEEP
	POP		BC
	POP		DE
ENDM

DRAWDIGITA	MACRO
	ADD		A,	32
	LD		(VIDMEM+%1+%2*40), A
ENDM

DRAWDIGIT	MACRO
	LD		A,	(%1)
	DRAWDIGITA	%2, %3
ENDM

DRAWDIGITND	MACRO
	PUSH	AF
	DRAWDIGIT	%1,	%2,	%3
	POP		AF
ENDM

SETBYTE		MACRO
	LD		A,	%2
	LD		(%1),	A
ENDM

SETBYTEND	MACRO				; Non destructive version of SETBYTE
	PUSH	AF
	SETBYTE	%1,	%2
	POP		AF
ENDM

PIXTOMEM	MACRO				; Load X/Y position from pointer arg1 and calculate memory address into HL
	LD		HL, (%1)			; Load obj pixel position into HL
	CALL	CALVAD
ENDM

POSTOPIX	MACRO				; Convert X/Y fixed-point position into pixel position and store in HL
	IF '%1'=='D'				; Convert & save X
		LD	A,	D
	ELSE
		LD	A,	(%1)
		SRL	A
		SRL	A
	ENDIF
	LD		L,	A

	IF '%2'=='E'				; Convert & save Y
		LD	A,	E
	ELSE
		LD	A,	(%2)
		SRL	A
		SRL	A
	ENDIF
	LD		H,	A
ENDM

POSTOMEM	MACRO
	POSTOPIX	%1,	%2
	CALL	CALVAD
ENDM

PRINTRA		MACRO				; Print the contents of A onto the screen as Hex value (non destructive to AF)
	PUSH	AF
	CALL	PRTBYT
	POP		AF
ENDM

STOOBJLAST	MACRO
	IF '%1' == 'X'
		LD		A,	(IX+0)
		LD		(IX+6),	A			; Store current xPos into lastX
	ENDIF
	IF '%1' == 'Y'
		LD		A,	(IX+1)
		LD		(IX+7),	A			; Store current yPos into lastY
	ENDIF
ENDM

;
;	C = PLAYERY < FLOORHEIGHT
;
TESTONFLOOR	MACRO				; C is set if not on floor (NC on floor)
	LD		A,	(PLAYERY)
	CP		(FLOORHEIGHT<<2)
ENDM

TESTONFLOORND	MACRO			; Non-Destructive version of TESTONFLOOR
	PUSH	AF
	TESTONFLOOR
	POP		AF
ENDM

CP16		MACRO				; Compare two 16-bit numbers without changing their values
	PUSH	HL
	PUSH	BC
	OR		A					; Clear carry flag
	SBC		HL,	BC
	POP		BC
	POP		HL
ENDM





;
;	CODE
;





	ORG		$1200

TITLESCREEN:
	CLS
	CURHOME
	PRINTLN	TITLE
	PRINTLN
	PRINTLN
	PRINTLN	MSGCONTINUE
	CALL	WAITKEYPRESS
	CLS							; force clear screen
	CALL	UPDATESCRDSP
DRAWFLOOR:
	LD		BC,	40
	LD		HL,	FLOORHEIGHT+1:00
	CALL	CALVAD
	EX		DE,	HL
	LD		HL,	FLOOR
	LDIR						; Block copy floor into VRAM
DRAWTEXT:
	LD		A,	$C1
	LD		B,	(FLOORHEIGHT+2)
DRAWTEXT1:
	CALL	MOVECU
	DJNZ	DRAWTEXT1
	PRINTLN	MSGSCORE

	CALL	DRAWPLAYER
	CALL	DRAWOBJS
	SLEEPX	$FF,	$FF
MAIN:

	CALL	BRKTST
	JP		Z,	GAMEOVER

	CALL	SNCV				; Wait for V-Blank before drawing

	; DEBUG
	PUSH	HL
	;CURHOME
	;LD		HL,	(PLAYERX)
	;CALL	PRTWRD
	;CALL	PRNTSPACE
	;LD		HL,	(PLAYVELX)
	;CALL	PRTWRD
	DRAWDIGIT	FLAGFLOOR,	0,	(FLOORHEIGHT+3)
	DRAWDIGIT	KEYDOWN,	2,	(FLOORHEIGHT+3)
	DRAWDIGIT	FLAGACCX,	4,	(FLOORHEIGHT+3)
	;DRAWDIGIT	SCORE,		6,	(FLOORHEIGHT+3)
	POP		HL

	CALL	DRAWPLAYER
	CALL	DRAWOBJS

	SLEEPX	$AA, $20 ;20
	
	CALL	CONTROLS
	CALL	CHECKKEYDOWN

CM:
	CALL	PROCESSOBJS
	CALL	MOVE
	CALL	CHKCOLLISION
	JP		MAIN


GAMEOVER:
	CALL	DRAWPLAYER
	CURHOME
	PRINTLN	MSGGAMOVR
	SLEEPX	$FF,	$FF
	SLEEPX	$FF,	$FF
	SLEEPX	$FF,	$FF
	CALL	WAITKEYPRESS
EXIT:
	CLS							; force clear screen
	PRINTLN	MSGEXIT
	JP		$00AD				; Exit to Monitor






;
;	FUNCTIONS
;






WAITKEYPRESS:
WAIT1:							; Wait while key is down
	CALL	GETKY
	JP		NZ,	WAIT1
WAIT2:							; Wait until key is pressed
	CALL	GETKY
	JP		Z,	WAIT2
	RET

; TODO: Change collision to be from the perspective of the objects.
; This should allow the system to know which object was hit.
; This may need to be done during rendering,
; or traditional collision calculations involving bounds could be used
CHKCOLLISION:
	POSTOMEM	PLAYERX,	PLAYERY
	LD		A,	(HL)
	CP		SPACESHIP
	JP		Z,	COLLISION
CHKCOLBELOW:
	LD		A,	(PLAYERX)
	ADD		A,	4
	LD		D,	A
	POSTOMEM	D,	PLAYERY
	LD		A,	(HL)
	CP		SPACESHIP
	JP		Z,	COLLISION
	RET
COLLISION:
	;POP		AF
	;JP		GAMEOVER
	LD		HL,	SCORE
	INC		(HL)
	CALL	UPDATESCRDSP
	RET

DRAWPLAYER:
	LD		HL,	(PLAYLASTXY)	; Clear last player location
	LD		(HL),	$00

	POSTOMEM PLAYERX, PLAYERY	; Save 
	LD		(PLAYLASTXY),	HL

	LD		(HL),	PLAYERSYM	; Draw player
	RET

DRAWOBJS:
	LD		B,	OBJCOUNT
DRAWOBJ:
	CALL	OBJHEADIDX			; Object header stored in IX

	;POSTOMEM	IX+6,	IX+7
	;LD		(HL),	$00			; Clear location

	CALL	CLEAR2DOBJ
	CALL	DRAW2DOBJ
	;POSTOMEM	IX,	IX+1
	;LD		A,	(IX+5)
	;LD		(HL),	A			; Draw object
	STOOBJLAST	X
	STOOBJLAST	Y

	DJNZ	DRAWOBJ
	RET

; TODO: Draw height
CLEAR2DOBJ:
	PUSH	BC
	LD		B,	(IX+3)			; Load width
	LD		D,	(IX+6)			; Load lastX
	SRL		D
	SRL		D
CLR2DWID:
	POSTOMEM	D,	IX+7
	LD		A,	D
	INC		D

	CP		40
	JP		NC,	CLEAR2DOBJEND
	CP		0
	JP		M,	C2DTSTLOOP

	LD		(HL),	$00			; Clear location
C2DTSTLOOP:
	DJNZ	CLR2DWID
CLEAR2DOBJEND:
	POP		BC
	RET

; TODO: Draw height
DRAW2DOBJ:
	PUSH	BC					; Save current state of BC
	LD		B,	(IX+3)			; Load width (int)
	LD		D,	(IX+0)			; Load xPos (fixed-point)
	SRL		D
	SRL		D
DRAW2DWID:
	POSTOMEM	D,	IX+1
	LD		A,	D
	INC		D

	CP		40
	JP		P,	DRAW2DOBJEND
	CP		0
	JP		M,	D2DTSTLOOP

	LD		A,	(IX+5)			; Load symbol
	LD		(HL),	A			; Draw object
D2DTSTLOOP:
	DJNZ	DRAW2DWID
DRAW2DOBJEND:
	POP		BC					; Load saves state of BC
	RET

;
;	keydown = 0;
;	if (key == LEFTKEY || key == RIGHTKEY) {
;		keydown = 1;
;	}
;
CHECKKEYDOWN:
	SETBYTE	KEYDOWN,	0		; Reset keydown
	CALL	GETKY				; 00 if not pressed
	CP		LEFTKEY
	JP		Z,	KEYDETECTOK
	CP		RIGHTKEY
	JP		Z,	KEYDETECTOK
	RET
KEYDETECTOK:
	SETBYTE	KEYDOWN,	1		; Set if left/right key detected
	RET

;
;	if (keydown == RIGHTKEY) {
;		BOOLRIGHT = 1;
;		PLAYVELX += 1;
;		PLAYVELX = PLAYVELX > MAXSPEED ? MAXSPEED;
;		return;
;	} else if (keydown == LEFTKEY) {
;		BOOLRIGHT = 0;
;		PLAYVELX -= 1;
;		PLAYVELX = PLAYVELX < -MAXSPEED ? -MAXSPEED;
;		return;
;	} else if (keydown == SPACEKEY) {
;		if (!onFloor()) return;
;		PLAYVELY = (-1<<3) -4;
;		PLAYERY -= 1;
;		return;
;	}
;
CONTROLS:
	CALL	GETKY
	RET		Z					; Do nothing if no key pressed
	CP		RIGHTKEY
	JP		Z,	MOVERIGHT		; if right pressed
	CP		LEFTKEY
	JP		Z,	MOVELEFT		; if left pressed
	CP		SPACEKEY			
	JP		Z,	JUMP			; if space pressed
	RET							; Return if neither left nor right were pressed
MOVERIGHT:
	SETBYTE	BOOLRIGHT,	1
	LD		A,	(PLAYVELX)
	INC		A
	CALL	CLAMPVELX
	LD		(PLAYVELX),	A
	RET
MOVELEFT:
	SETBYTE	BOOLRIGHT,	0
	LD		A,	(PLAYVELX)
	DEC		A
	CALL	CLAMPVELX
	LD		(PLAYVELX),	A
	RET
JUMP:
	TESTONFLOOR					; Check if on floor
	RET		C					; Return if player is not on the floor
	SETBYTE	PLAYVELY,	JUMPSPEED
	LD		A,	(PLAYERY)
	DEC		A
	LD		(PLAYERY),	A
	RET

CLAMPVELX:						; This assumes xVel is loaded into reg A
	CP		0
	JP		M,	CVXNEG
CVXPOS:
	CP		MAXSPEED
	JP		P,	CVXPOSMAX
	RET
CVXNEG:
	CP		-MAXSPEED
	JP		M,	CVXNEGMAX
	RET
CVXPOSMAX:
	LD		A,	MAXSPEED
	RET
CVXNEGMAX:
	LD		A,	-MAXSPEED
	RET

MOVE:							; Update playerx and playery values
	SETBYTEND	FLAGFLOOR,	0	; Reset onFloor flag
	TESTONFLOOR					; Check if on floor
	LD		A,	0				; If on floor, set yVel to 0 (p1)
	JP		NC,	MOVE1			; If on floor, skip yVel calculations
	SETBYTEND	FLAGFLOOR,	1	; Set onFloor flag
	LD		A,	(PLAYERY)		; Add yVel to yPos
	LD		HL,	PLAYVELY
	ADD		A,	(HL)
	LD		(PLAYERY),	A

	TESTONFLOOR					; Check if on or below floor and fix yPos and yVel
	JP		C,	MOVE2			; If not on floor, add gravity
	LD		A,	FLOORHEIGHT<<2	; If on or below floor, set yPos to floor
	LD		(PLAYERY),	A
	LD		A,	0				; If on floor, set yVel to 0 (p1)
	JP		MOVE1				; Skip gravity if on floor
MOVE2:
	; Update Y velocity
	LD		A,	(PLAYVELY)
	ADD		A,	GRAVITY
MOVE1:
	LD		(PLAYVELY),	A		; set yVel to either 0 or yVel-gravity (p2)
	LD		A,	(KEYDOWN)		; Test if a key is currently being held
	OR		A
	JP		NZ,	MOVEX			; If a key is pressed, move

	SETBYTE	FLAGACCX,	9

	LD		A,	(FLAGFLOOR)		; If not on floor, skip friction calculation
	OR		A
	JP		NZ,	MOVEX

	LD		A,	(PLAYVELX)
	CALL	STEPTOZERO			; Gradually reduce Xvel to 0 if no key pressed
	LD		(PLAYVELX),	A
MOVEX:
	LD		A,	(PLAYVELX)		; Add Xvel to Xpos
	LD		HL,	PLAYERX
	ADD		A,	(HL)
	LD		(PLAYERX),	A
MOVEXWALL:						; Wrap player around screen
	SRL		A					; Remove a digit of precision to circumvent signed-byte limitations
	CP		-10					; ngl, I have no clue why this works
	JP		M,	MOVEXWALLLEFT	; Player has gone left off screen
	CP		(39<<1)+1
	RET		M					; Player has not gone right off screen
MOVEXWALLRIGHT:
	SETBYTE	PLAYERX,	0		; Wrap player around to left side
	RET
MOVEXWALLLEFT:
	SETBYTE	PLAYERX,	39<<2	; Wrap player around to right side
	RET

IMULT:							; Multiply D by E and store the result in HL (destructive to BC,DE,AF)
	LD		HL,	0
	LD		A,	D
	OR		A
	RET		Z
	LD		B,	D
	LD		D,	H
IML:
	ADD		HL,	DE
	DJNZ	IML
	RET

IDIV:							; Divide D by E and store the result in D with remainder in E
	LD		A,	D
	LD		D,	0
IDV:
	CP		E
	JP		C,	IDVDONE
	SUB		E
	INC		D
	JP		IDV
IDVDONE:
	LD		E,	A				; Store remainder
	RET

SLEEP:							; Sleep for a given number of iterations
	LD		A,	(SLEEPCOUNT)
SLEEP1:
	SUB		1
	OR		A
	JP		NZ,	SLEEP1
	DJNZ	SLEEP
	RET

STEPTOZERO:						; INC/DEC A towards zero depending on polarity
	SETBYTEND	FLAGACCX,	0
	CP		0
	RET		Z					; Already zero
	JP		M,	STZNEG			; Negative
STZPOS:
	SETBYTEND	FLAGACCX,	1
	DEC		A
	RET
STZNEG:
	SETBYTEND	FLAGACCX,	2
	INC		A
	RET

RAND8:							; Generate a pseudo-random number (not great, but good enough)
	LD		A,	(RSEED)
	AND		$B8
	SCF
	JP		PO,	RANDNOCLR
	CCF
RANDNOCLR:
	LD		HL,	RSEED
	LD		A,	R
	ADD		A,	(HL)
	RLA
	LD		(RSEED),	A
	RET

PROCESSOBJS:					; Updates all enemy objects
	LD		B,	OBJCOUNT		; Number of objects to cycle through
UPDATEOBJ:
	; TODO: add component count instead of multiplying since the objs are referenced in order anyway
	CALL	OBJHEADIDX			; Calculate memory address

	LD		A,	(IX+0)			; Load xPos
	ADD		A,	(IX+2)			; Add xVel to xPos
	LD		(IX+0),	A
	SRL		A
	CP		-8
	CALL	M,	OBJLEFT

	DJNZ	UPDATEOBJ			; Loop if there are still objects to process
	RET

OBJHEADIDX:						; Save address of object header in IX based on object index stored in B
	LD		E,	B
	DEC		E
	LD		D,	OBJVALS			; Number of elements in each object
	PUSH	BC
	CALL	IMULT
	POP		BC
	EX		DE,	HL
	LD		IX,	OBJECTDEFS
	ADD		IX,	DE				; Calculate the memory address for the next object and store in IX
	RET

OBJLEFT:
	CALL	OBJRESET
	; TODO: Steps to take when obj leaves the screen
	RET

OBJRESET:						; Resets object at header IX
	CALL	RAND8
	AND		0011_1100B
	ADD		A,	3<<2
	LD		(IX+1),	A

	LD		(IX+0),	39<<2
	RET

UPDATESCRDSP:
	LD		A,	(SCORE)
	LD		D,	A
	LD		E,	100
	CALL	IDIV
	LD		A,	D
	DRAWDIGITA	7, (FLOORHEIGHT+2)

	LD		D,	E
	LD		E,	10
	CALL	IDIV
	LD		A,	D
	DRAWDIGITA	8, (FLOORHEIGHT+2)

	LD		A,	E
	DRAWDIGITA	9, (FLOORHEIGHT+2)

	RET

; TODO: Verify characters are being assembled correctly
CHRMAP		"MZ-ASCII-EU"

MSGGAMOVR:	DB	"               GAME OVER               ", $0D
FLOOR:		DS	40, $F3
MSGEXIT:	DB	"EXITED PROGRAM", $0D
MSGSCORE:	DB	"SCORE:", $0D
SLEEPCOUNT:	DS	2	; Reserve 2 bytes of memory (zeroed)
RSEED:		DB	$A1
BOOLRIGHT:	DB	$01
KEYDOWN:	DB	$00	; If a key is being held down
PLAYERX:	DB	$14<<2
PLAYERY:	DB	FLOORHEIGHT<<2
PLAYVELX:	DB	$00
PLAYVELY:	DB	$00
PLAYLASTXY:	DS	2	
FLAGFLOOR:	DB	$00	; An indicator flag for debugging
FLAGACCX:	DB	$00
SCORE:		DB	$00

TITLE: 					             
DB	"       ...........................      "
DB	"      ##.....##..#######..########.     "
DB	"      ##.....##.##.....##.##.....##     "
DB	"      ##.....##.##.....##.##.....##     "
DB	"      #########.##.....##.########.     "
DB	"      ##.....##.##.....##.##.......     "
DB	"      ##.....##.##.....##.##.......     "
DB	"      ##.....##..#######..##.......     "
DB	"     ..............................     "
DB	"    .######..##....##.####.########.    "
DB	"    ##....##.##...##...##..##.....##    "
DB	"    ##.......##..##....##..##.....##    "
DB	"    .######..#####.....##..########.    "
DB	"    ......##.##..##....##..##.......    "
DB	"    ##....##.##...##...##..##.......    "
DB	"    .######..##....##.####.##.......    "
DB	"     ..............................     ", $0D
MSGCONTINUE:
DB	"    PRESS ANY KEY TO CONTINUE...", $0D



;
; Objects to dodge
;
; 0: xPos | 1: yPos | 2: xVel | 3: width | 4: height | 5: sym | 6: lastX | 7: lastY
OBJECTDEFS:
OBJ1H:		DB	45<<2,	6<<2,	-0000_0100B,	4,	2,	SPACESHIP,	0,	0
OBJ2H:		DB	50<<2,	10<<2,	-0000_0011B,	4,	2,	SPACESHIP,	0,	0
OBJ3H:		DB	40<<2,	13<<2,	-0000_0010B,	4,	2,	SPACESHIP,	0,	0
OBJ4H:		DB	60<<2,	17<<2,	-0000_0001B,	4,	2,	SPACESHIP,	0,	0

END