;
;	MONITOR FUNCTIONS
;

GETL		EQU	$0003	; Inputs one line of text from the keyboard.
CRLF2		EQU	$0006	; Places cursor at start of new line
CRLF		EQU	$0009	; Places cursor at start of new line if it wasn't already at the start
PRNTSPACE	EQU	$000C	; Print a space character
PRNT		EQU	$0012	; Print a character (or control)
MESSAGE		EQU	$0015	; Print a string
GETKY		EQU	$001B	; Get the current key pressed
PRTWRD		EQU	$03BA	; Output a 16-bit hexadecimal number contained in HL to the screen
PRTBYT		EQU	$03C3	; Output a hexadecimal number contained in A to the screen
DIGASC		EQU	$03DA	
DISPAC		EQU	$0BCE	; Convert a display code stored in A into its ASCII code
ASCWRD		EQU	$0410	; Convert AF,HL ASCII into hex and store in HL
CALVAD		EQU	$0FB4	; Compute the vram address of pixel position stored in HL (H=row, L=col)

;
;	EQUATES
;

FLOORHEIGHT	EQU	21
GRAVITY		EQU	1


; CHARACTERS
SPACESHIP	EQU	$C7
PLAYERSYM	EQU	$DF

; KEYS
LEFTKEY		EQU	$41
RIGHTKEY	EQU	$44
SPACEKEY	EQU	$20

; ADDRESSES
VIDMEM      EQU $D000

;
;	MACROS
;

PRINT		MACRO
	LD		DE,	%1
	CALL	MESSAGE
ENDM

PRINTLN		MACRO
	IF '%1'
		PRINT %1
		CALL CRLF
	ELSE
		CALL CRLF2
	ENDIF
ENDM

CURHOME		MACRO
	LD		A,	$15
	CALL	PRNT
ENDM

CLS			MACRO
	LD		A,	$16
	CALL	PRNT
ENDM

SLEEPX		MACRO				; Sleep for 0x?? * 0x?? iterations
	PUSH	DE
	PUSH	BC
	IF %1<1
		LD DE, 1
	ELSE
		LD DE, %1
	ENDIF
	
	IF '%2'
		IF %2<1
			LD B, 1
		ELSE
			LD B, %2
		ENDIF
	ELSE
		LD B, 1
	ENDIF
	LD		(SLEEPCOUNT),	DE
	CALL	SLEEP
	POP		BC
	POP		DE
ENDM

DRAWBOOL	MACRO
	LD		A,	(%1)
	ADD		A,	32
	LD		(VIDMEM+%2+%3*40), A
ENDM

SETBYTE		MACRO
	LD		A,	%2
	LD		(%1),	A
ENDM

PIXTOMEM	MACRO				; Load X/Y position from pointer arg1 and calculate memory address into HL
	LD		HL, (%1)			; Load obj pixel position into HL
	CALL	CALVAD
ENDM

POSTOPIX	MACRO				; Convert X/Y fixed-point position into pixel position and store in HL
	LD		A,	(%1)			; Convert & save X
	SRL		A
	SRL		A
	LD		L,	A

	LD		A,	(%2)			; Convert & save Y
	SRL		A
	SRL		A
	LD		H,	A
ENDM

POSTOMEM	MACRO
	POSTOPIX	%1,	%2
	CALL	CALVAD
ENDM

PRINTRA		MACRO				; Print the contents of A onto the screen as Hex value (non destructive to AF)
	PUSH	AF
	CALL	PRTBYT
	POP		AF
ENDM

;
;	C = PLAYERY < FLOORHEIGHT - 0.25
;
TESTONFLOOR	MACRO				; C is set if not on floor
	LD		A,	(PLAYERY)
	CP		(FLOORHEIGHT<<2) - 1
ENDM



;
;	CODE
;





	ORG		$1200

	CLS							; force clear screen
DRAWFLOOR:
	LD		BC,	40
	LD		HL,	FLOORHEIGHT+1:00
	CALL	CALVAD
	EX		DE,	HL
	LD		HL,	FLOOR
	LDIR
START:
	POSTOMEM	PLAYERX,	PLAYERY

    LD      (HL),   PLAYERSYM	; Draw player

	; DEBUG
	PUSH	HL
	CURHOME
	LD		HL,	(PLAYERX)
	CALL	PRTWRD
	DRAWBOOL	FLAG,	0,	1
	DRAWBOOL	KEYDOWN,	0,	2
	POP		HL

	;REPT	4
		SLEEPX	$AA, $10
		CALL	CONTROLS
		CALL	CHECKKEYDOWN
	;ENDM
	; TODO: Fix flickering
	LD		(HL),	$00			; Clear location
CM:
	CALL	MOVE
	JP		START


WAIT1:							; Wait while key is down
	CALL	GETKY
	JP		NZ,	WAIT1
WAIT2:							; Wait until key is pressed
	CALL	GETKY
	JP		Z,	WAIT2
EXIT:
	CLS							; force clear screen
	PRINTLN	MSGEXIT
	JP		$00AD				; Exit to Monitor


;
;	FUNCTIONS
;


;
;	if(key == 0) { // no input
;		keydown = 0;
;	} else { // detected input
;		if(keydown == 0) { // not being held
;			keydown = 1;
;		}
;	}
;
CHECKKEYDOWN:
	CALL	GETKY				; 00 if not pressed
	OR		A
	JP		NZ,	KEYDETECT		; jump if detected keypress
	LD		A,	0
	LD		(KEYDOWN), A		; Reset keydown if no key detected
	RET
KEYDETECT:
	LD		A,	(KEYDOWN)
	OR		A					; zero if KEYDOWN=0
	RET		NZ					; return if key was being held down prior to current detection
	LD		A,	1
	LD		(KEYDOWN), A		; Set keydown if keypress detected
	RET

;
;	if(keydown == RIGHTKEY) {
;		BOOLRIGHT = 1;
;		return;
;	}
;	if(keydown == LEFTKEY) {
;		BOOLRIGHT = 0;
;		return;
;	}
;
CONTROLS:
	CALL	GETKY
	LD		D,	A
	RET		Z					; Do nothing if no key pressed
	SUB		RIGHTKEY
	JP		Z,	SETRIGHT		; if right pressed
	LD		A,	D
	SUB		LEFTKEY
	JP		Z,	SETLEFT			; if left pressed
	LD		A,	D
	SUB		SPACEKEY			; if space pressed
	JP		Z,	JUMP
	RET							; Return if neither left nor right were pressed
SETRIGHT:
	SETBYTE	BOOLRIGHT,	1
	RET
SETLEFT:
	SETBYTE	BOOLRIGHT,	0
	RET
JUMP:
	TESTONFLOOR					; Check if on floor
	RET		C					; Return if player is not on the floor
	SETBYTE	PLAYVELY,	(-1<<3) -4
	LD		A,	(PLAYERY)
	SUB		1<<1
	LD		(PLAYERY), A
	RET

TOGGLEDIR:
	LD		A,	(BOOLRIGHT)
	XOR		1
	LD		(BOOLRIGHT),	A
	RET



MOVE:							; Update playerx and playery values
	; Gravity
	TESTONFLOOR					; Check if on floor
	SETBYTE	FLAG,	0
	LD		A,	0				; If on floor, set Y velocity to 0 (p1)
	JP		NC,	MOVE1			; If on floor, skip gravity
	SETBYTE	FLAG,	1
	LD		A,	(PLAYERY)		; Increment PLAYERY if not on floor
	LD		HL,	PLAYVELY
	ADD		A,	(HL)
	LD		(PLAYERY),	A

	TESTONFLOOR					; Check if on or below floor and fix ypos and yvel
	JP		C,	MOVE2			; If not on floor, add gravity
	LD		A,	FLOORHEIGHT<<2	; If on or below floor, set y to floor
	LD		(PLAYERY),	A
	LD		A,	0
	JP		MOVE1

MOVE2:
	; Update Y velocity
	LD		A,	(PLAYVELY)
	ADD		A,	GRAVITY
MOVE1:
	LD		(PLAYVELY),	A		; set Y velocity to either 0 or Yvel-Gravity (p2)
	; Ensure key is currently being held
	LD		A,	(KEYDOWN)
	OR		A
	RET		Z
	; Test direction
	LD		A,	(BOOLRIGHT)		; Check direction
	OR		A
	JP		NZ,	RIGHT			; Right?=True, Move right
LEFT:							; Right?=False, Move left
	LD		A,	(PLAYERX)
	OR		A
	RET		Z					; Do nothing if playerx is already 0
	DEC		A		; TODO: Change to velocity
	LD		(PLAYERX),	A
	RET
RIGHT:
	LD		A,	(PLAYERX)
	SUB		39<<2
	RET		Z					; Do nothing if playerx is on right-side of screen
	LD		A,	(PLAYERX)
	INC		A		; TODO: Change to velocity
	LD		(PLAYERX),	A
	RET

IMULT:							; Multiply D by E and store the result in HL.
	LD		HL,	0
	LD		A,	D
	OR		A
	RET		Z
	LD		B,	D
	LD		D,	H
IML:
	ADD		HL,	DE
	DJNZ	IML
	RET

SLEEP:							; Sleep for a given number of iterations
	LD		A,	(SLEEPCOUNT)
SLEEP1:
	SUB		1
	OR		A
	JP		NZ,	SLEEP1
	DJNZ	SLEEP
	RET

; TODO: Verify characters are being assembled correctly
; CHRMAP		"MZ-ASCII-EU"

MSG1:		DB	"ENTER 2* 2-DIGIT HEX #S W/O SPACE", $0D
FLOOR:		DB	"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"
MSGR:		DB	" RIGHT ", $0D
MSGL:		DB	" LEFT ", $0D
MSGRES:		DB	"RESULT:", $0D
MSGEXIT:	DB	"EXITED PROGRAM", $0D
SLEEPCOUNT:	DS	2	; Reserve 2 bytes of memory (zeroed)
BOOLRIGHT:	DB	$01
KEYDOWN:	DB	$00	; If a key is being held down
PLAYERX:	DB	$00
PLAYERY:	DB	FLOORHEIGHT<<2
PLAYVELX:	DB	$00
PLAYVELY:	DB	$00
FLAG:		DB	$00	; An indicator flag for debugging

END

